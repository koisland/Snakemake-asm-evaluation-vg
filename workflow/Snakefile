import os
import glob
from os.path import join


ASSEMBLIES = config["assemblies"]
REGIONS = config["regions"]
ANNOTATIONS = config.get("annotations", [])
OUTPUT_DIR = config["output_dir"]
LOG_DIR = config["log_dir"]
BENCHMARK_DIR = config["benchmark_dir"]

THREADS_MM2 = config["threads_mm2"]
MEM_MM2 = config["mem_mm2"]
THREADS_MG = config["threads_mg"]
MEM_MG = config["mem_mg"]


wildcard_constraints:
    region=r"(.+):([0-9]+)-([0-9]+)",


rule merge_asm:
    input:
        asm=ASSEMBLIES,
    output:
        fa=join(OUTPUT_DIR, "merged_asm.fa.gz"),
    benchmark:
        join(BENCHMARK_DIR, "merge_asm.tsv")
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "merge_asm.log"),
    shell:
        """
        {{ zcat -f {input.asm} | seqkit rmdup | bgzip ;}} > {output.fa} 2> {log}
        samtools faidx {output.fa} 2>> {log}
        """


rule ava_asm:
    input:
        asm=rules.merge_asm.output,
    output:
        paf=join(OUTPUT_DIR, "ava_asm.paf.gz"),
    threads: THREADS_MM2
    resources:
        mem=MEM_MM2,
    params:
        preset="asm5",
        added_params="-K 8G",
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "ava_asm.log"),
    benchmark:
        join(BENCHMARK_DIR, "ava_asm.tsv")
    shell:
        """
        {{ minimap2 \
        -x {params.preset} \
        -t {threads} \
        {params.added_params} \
        --eqx --cs -c \
        {input.asm} \
        {input.asm} | bgzip ;}} > {output.paf} 2> {log}
        """


checkpoint split_regions:
    input:
        regions=REGIONS,
    output:
        fofn=join(OUTPUT_DIR, "regions", "region_beds.fofn"),
    params:
        outdir=join(OUTPUT_DIR, "regions", "bed"),
    shell:
        """
        mkdir -p {params.outdir}
        awk -v OFS="\\t" '{{
            region=$1":"$2"-"$3;
            outfile="{params.outdir}/"region".bed"
            print $1, $2, $3 > outfile
            print outfile > "{output.fofn}"
        }}' {input.regions}
        """


rule query_regions:
    input:
        paf=rules.ava_asm.output.paf,
        asm=rules.merge_asm.output,
        bed=join(rules.split_regions.params.outdir, "{region}.bed"),
    output:
        fa_dir=directory(join(OUTPUT_DIR, "regions", "fasta", "{region}")),
    log:
        join(LOG_DIR, "query_regions_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "query_regions_{region}.tsv")
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ impg query \
        -p {input.paf} \
        -b {input.bed} \
        -o fasta \
        --sequence-files {input.asm} | 
        seqkit split -i - --by-id-prefix "" -O {output.fa_dir} ;}} 2> {log}
        """


rule run_minigraph:
    input:
        fa_dir=rules.query_regions.output,
    output:
        rgfa=join(OUTPUT_DIR, "graphs", "{region}.rgfa"),
        gfa=join(OUTPUT_DIR, "graphs", "{region}_segment_named.gfa"),
    params:
        min_mapq=1,
        min_variant_length=1,
        min_alignment_length=10,
        min_alignment_length_depth=10,
        region_seqkit=lambda wc: wc.region.replace(":", "__"),
        script=workflow.source_path("scripts/rename_segments.py"),
    log:
        join(LOG_DIR, "generate_variation_graph_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "generate_variation_graph_{region}.tsv")
    threads: THREADS_MG
    resources:
        mem=MEM_MG,
    conda:
        "envs/tools.yaml"
    shell:
        """
        ref_fasta=$(find {input.fa_dir} -name "*.fasta" -and -name "{params.region_seqkit}.fasta")
        qry_fasta=$(find {input.fa_dir} -name "*.fasta" -and -not -name "{params.region_seqkit}.fasta")
        if [ -z "${{qry_fasta}}" ] || [ -z "${{ref_fasta}}" ]; then
            touch {output}
            exit 0
        fi
        minigraph \
        -cx ggs \
        -t{threads} \
        ${{ref_fasta}} \
        ${{qry_fasta[@]}} \
        -q {params.min_mapq} \
        -L {params.min_variant_length} \
        -l {params.min_alignment_length} \
        -d {params.min_alignment_length_depth} > {output.rgfa} 2> {log}
        # Convert to GFAv1.1 where segments are renamed to SN tag.
        python {params.script} {output.rgfa} > {output.gfa} 2>> {log}
        """


# https://github.com/lh3/minigraph?tab=readme-ov-file#calling-structural-variations
rule call_bubbles:
    input:
        gfa=rules.run_minigraph.output.gfa,
    output:
        bed_raw=join(OUTPUT_DIR, "bed", "{region}_bubbles_raw.bed"),
        bed=join(OUTPUT_DIR, "bed", "{region}_bubbles.bed"),
    log:
        join(LOG_DIR, "call_bubbles_{region}.log"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ gfatools bubble {input.gfa} | \
        tee {output.bed_raw} | \
        awk -v OFS="\\t" '{{
            match($1, "^(.*?):([0-9]+)-([0-9]+)$", mtches);
            $1=mtches[1];
            start=$2+mtches[2];
            end=$3+mtches[2];
            $2=start;
            $3=end;
            print
        }}' ;}} > {output.bed} 2> {log}
        """


rule convert_rgfa_to_gbz:
    input:
        rgfa=rules.run_minigraph.output.rgfa,
    output:
        gfa=join(OUTPUT_DIR, "graphs", "{region}.gfa"),
        gbz=join(OUTPUT_DIR, "graphs", "{region}.gbz"),
    log:
        join(LOG_DIR, "convert_rgfa_to_gbz_{region}.log"),
    params:
        rgfa_prefix=lambda wc: wc.region.split("_")[0]
    conda:
        "envs/tools.yaml"
    shell:
        """
        vg convert -f --rgfa-prefix "{params.rgfa_prefix}" --rgfa-pline {input.rgfa} > {output.gfa} 2> {log}
        vg gbwt -G {output.gfa} --gbz-format -g {output.gbz} 2>> {log}
        """


rule merge_format_annotations:
    input:
        ANNOTATIONS,
    output:
        bed=join(OUTPUT_DIR, "bed", "merged_annotations.bed"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        zcat -f {input} | cut -f 1-4 | sort -k1,1 -k2,2n > {output.bed}
        """


rule convert_annot_to_path_coords:
    input:
        bed=rules.merge_format_annotations.output,
    output:
        bed=join(OUTPUT_DIR, "bed", "{region}_annot.bed"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        # Convert region wildcard to BED file in relative coordinate system.
        # * First convert to path system, strip the coordinates, intersect with bed, and then add them back and revert back to path system.
        # * Add increment so all path names are unique.
        bedtools intersect \
            -a {input.bed} \
            -b <(
                echo "{wildcards.region}" | \
                awk -v OFS="\\t" '{{
                    match($1, "^(.*?):([0-9]+)-([0-9]+)$", mtch);
                    print mtch[1], mtch[2], mtch[3]
            }}') \
            -wa -wb | \
        awk -v OFS="\\t" '{{
            chrom_st=$(NF-1);
            chrom_end=$(NF);
            path_st=0;
            path_len=chrom_end-chrom_st; 
            path_end=path_len;
            new_st=$2-chrom_st;
            new_st=(new_st > 0) ? new_st + 1 : 0;
            new_end=$3-chrom_st;
            new_end=(new_end > path_len) ? path_len : new_end;
            path_name=$1":"path_st"-"path_end
            print path_name, new_st, new_end + 1, $4"_"NR
        }}' > {output.bed}
        """


rule annotate_graph:
    input:
        gbz=rules.convert_rgfa_to_gbz.output.gbz,
        bed=rules.convert_annot_to_path_coords.output.bed,
    output:
        gaf=join(OUTPUT_DIR, "graphs", "{region}.gaf.gz"),
        tbi=join(OUTPUT_DIR, "graphs", "{region}.gaf.gz.tbi"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        vg annotate -x {input.gbz} \
        -b {input.bed} \
        -F | bgzip > {output.gaf}
        tabix -p gaf {output.gaf}
        """


def graph_outputs(wc):
    fofn = checkpoints.split_regions.get(**wc).output.fofn
    regions = []
    with open(fofn, "rt") as fh:
        for bed in fh:
            bed = bed.strip()
            with open(bed, "rt") as bfh:
                for line in bfh:
                    chrom, st, end = line.strip().split("\t")
                    regions.append(f"{chrom}:{st}-{end}")
    outputs = {
        "gfa": expand(rules.run_minigraph.output.gfa, region=regions),
        "bubbles": expand(rules.call_bubbles.output.bed, region=regions),
    }
    if ANNOTATIONS:
        outputs["gaf"] = expand(rules.annotate_graph.output, region=regions)

    return outputs


rule generate_variation_graph_output:
    input:
        unpack(graph_outputs),
        region_fofn=rules.split_regions.output,
    output:
        bubbles=join(OUTPUT_DIR, "bed", "all_bubbles.bed")
    params:
        bubbles=lambda wc, input: input.bubbles if hasattr(input, "bubbles") else ""
    shell:
        """
        sort -k1,1 -k2,2n {params.bubbles} > {output.bubbles}
        """


rule all:
    input:
        rules.generate_variation_graph_output.output,
    default_target: True
