import os
import glob
from os.path import join


ASSEMBLIES = config["assemblies"]
REGIONS = config["regions"]
ANNOTATIONS = config["annotations"]
OUTPUT_DIR = config["output_dir"]
LOG_DIR = config["log_dir"]
BENCHMARK_DIR = config["benchmark_dir"]

THREADS_MM2 = config["threads_mm2"]
MEM_MM2 = config["mem_mm2"]
THREADS_MG = config["threads_mg"]
MEM_MG = config["mem_mg"]


if isinstance(REGIONS, str) and os.path.exists(REGIONS):
    all_regions = []
    with open(REGIONS, "rt") as fh:
        for line in fh:
            chrom, st, end, *_ = line.strip().split("\t")
            all_regions.append(f"{chrom}:{st}-{end}")
elif isinstance(REGIONS, str):
    all_regions = [REGIONS]
elif isinstance(REGIONS, list):
    all_regions = REGIONS



wildcard_constraints:
    region="|".join(all_regions)


rule merge_asm:
    input:
        asm=ASSEMBLIES,
    output:
        fa=join(OUTPUT_DIR, "merged_asm.fa.gz"),
    benchmark:
        join(BENCHMARK_DIR, "merge_asm.tsv")
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "merge_asm.log"),
    shell:
        """
        {{ zcat -f {input.asm} | seqkit rmdup | bgzip ;}} > {output.fa} 2> {log}
        samtools faidx {output.fa} 2>> {log}
        """


rule ava_asm:
    input:
        asm=rules.merge_asm.output,
    output:
        paf=join(OUTPUT_DIR, "ava_asm.paf.gz"),
    threads: THREADS_MM2
    resources:
        mem=MEM_MM2,
    params:
        preset="asm5",
        added_params="-K 8G",
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "ava_asm.log"),
    benchmark:
        join(BENCHMARK_DIR, "ava_asm.tsv")
    shell:
        """
        {{ minimap2 \
        -x {params.preset} \
        -t {threads} \
        {params.added_params} \
        --eqx --cs -c \
        {input.asm} \
        {input.asm} | bgzip ;}} > {output.paf} 2> {log}
        """


checkpoint query_regions:
    input:
        paf=rules.ava_asm.output.paf,
        asm=rules.merge_asm.output,
    output:
        fa_dir=directory(join(OUTPUT_DIR, "regions", "{region}")),
    log:
        join(LOG_DIR, "query_regions_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "query_regions_{region}.tsv")
    params:
        region="{region}",
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ impg query \
        -p {input.paf} \
        -r {params.region} \
        -o fasta \
        --sequence-files {input.asm} | 
        seqkit split -i - --by-id-prefix "" -O {output.fa_dir} ;}} 2> {log}
        """


rule run_minigraph:
    input:
        fa_dir=rules.query_regions.output,
    output:
        rgfa=join(OUTPUT_DIR, "graphs", "{region}.rgfa"),
        gfa=join(OUTPUT_DIR, "graphs", "{region}.gfa"),
    params:
        min_mapq=1, 
        min_variant_length=1, 
        min_alignment_length=10,
        min_alignment_length_depth=10,
    log:
        join(LOG_DIR, "generate_variation_graph_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "generate_variation_graph_{region}.tsv")
    threads: THREADS_MG
    resources:
        mem=MEM_MG,
    conda:
        "envs/tools.yaml"
    shell:
        """
        minigraph \
        -cx ggs \
        -t{threads} \
        {input.fa_dir}/*.fasta \ # TODO: Make sure reference always the region.
        -q {params.min_mapq} \
        -L {params.min_variant_length} \
        -l {params.min_alignment_length} \
        -d {params.min_alignment_length_depth} > {output.rgfa} 2> {log}
        # Convert to GFAv1.1
        vg convert -g -f -W {output.rgfa} > {output.gfa} 2>> {log}
        """


rule convert_gfa_to_og:
    input:
        gfa=rules.run_minigraph.output.gfa
    output:
        og=join(OUTPUT_DIR, "graphs", "{region}.og"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        odgi build -g {input.gfa} -o {output.og}
        """


rule merge_format_annotations:
    input:
        ANNOTATIONS
    output:
        bed=join(OUTPUT_DIR, "bed", "merged_annotations.bed"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        zcat -f {input} | cut -f 1-4 | sort -k1,1 -k2,2n > {output.bed}
        """

rule inject_annot_and_cvt_to_gfa:
    input:
        og=rules.convert_gfa_to_og.output.og,
        annotations=rules.merge_format_annotations.output,
    output:
        bed_inj=join(OUTPUT_DIR, "bed", "{region}_injected.bed"),
        og_inj=join(OUTPUT_DIR, "graphs", "{region}_injected.og"),
        gfa_inj=join(OUTPUT_DIR, "graphs", "{region}_injected.gfa"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        # Convert region wildcard to BED file in relative coordinate system.
        # * First convert to path system, strip the coordinates, intersect with bed, and then add them back and revert back to path system.
        # * Add increment so all path names are unique.
        # * odgi procbed's path name parsing didn't work for me.
        bedtools intersect \
            -a {input.annotations} \
            -b <(odgi paths -Ll -i {input.og} | awk -v OFS="\\t" '{{ match($1, "^(.+):(.+)-", arr); print arr[1], $2+arr[2], $3+arr[2], arr[2]}}') \
            -wa -wb | \
        awk -v OFS="\\t" '{{
            path_st=$(NF-2);
            path_end=$(NF-1);
            path_len=path_end-path_st; 
            chrom_st=$(NF);
            new_st=$2-chrom_st;
            new_st=(new_st > 0) ? new_st + 1 : 0;
            new_end=$3-chrom_st;
            new_end=(new_end > path_len) ? path_len : new_end;
            path_name=$1":"path_st-1"-"path_end
            print path_name, new_st, new_end + 1, $4"_"NR
        }}' > {output.bed_inj}
        odgi inject -i {input.og} -b {output.bed_inj} -o {output.og_inj}
        odgi view -i {output.og_inj} --to-gfa > {output.gfa_inj}
        """

# TODO: Call variants and overlap with regions.

def variant_graphs(wc) -> list[str]:
    output_dir = checkpoints.query_regions.get(**wc).output[0]
    files = glob.glob(join(output_dir, "*.fasta"))

    if len(files) < 2:
        return []
    
    return [
        *expand(rules.run_minigraph.output, region=wc.region),
        *expand(rules.inject_annot_and_cvt_to_gfa.output, region=wc.region),
    ]


rule generate_variation_graphs:
    input:
        variant_graphs
    output:
        touch(join(OUTPUT_DIR, "checkpoints", "graph_{region}.done"))


rule all:
    input:
        expand(rules.generate_variation_graphs.output, region=all_regions),
    default_target: True
