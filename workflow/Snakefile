import os
import glob
from os.path import join


ASSEMBLIES = config["assemblies"]
REGIONS = config["regions"]
ANNOTATIONS = config["annotations"]
OUTPUT_DIR = config["output_dir"]
LOG_DIR = config["log_dir"]
BENCHMARK_DIR = config["benchmark_dir"]

THREADS_MM2 = config["threads_mm2"]
MEM_MM2 = config["mem_mm2"]
THREADS_MG = config["threads_mg"]
MEM_MG = config["mem_mg"]

wildcard_constraints:
    region=r"(.+):([0-9]+)-([0-9]+)"

rule merge_asm:
    input:
        asm=ASSEMBLIES,
    output:
        fa=join(OUTPUT_DIR, "merged_asm.fa.gz"),
    benchmark:
        join(BENCHMARK_DIR, "merge_asm.tsv")
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "merge_asm.log"),
    shell:
        """
        {{ zcat -f {input.asm} | seqkit rmdup | bgzip ;}} > {output.fa} 2> {log}
        samtools faidx {output.fa} 2>> {log}
        """


rule ava_asm:
    input:
        asm=rules.merge_asm.output,
    output:
        paf=join(OUTPUT_DIR, "ava_asm.paf.gz"),
    threads: THREADS_MM2
    resources:
        mem=MEM_MM2,
    params:
        preset="asm5",
        added_params="-K 8G",
    conda:
        "envs/tools.yaml"
    log:
        join(LOG_DIR, "ava_asm.log"),
    benchmark:
        join(BENCHMARK_DIR, "ava_asm.tsv")
    shell:
        """
        {{ minimap2 \
        -x {params.preset} \
        -t {threads} \
        {params.added_params} \
        --eqx --cs -c \
        {input.asm} \
        {input.asm} | bgzip ;}} > {output.paf} 2> {log}
        """

checkpoint split_regions:
    input:
        regions=REGIONS
    output:
        fofn=join(OUTPUT_DIR, "regions", "region_beds.fofn")
    params:
        outdir=join(OUTPUT_DIR, "bed")
    shell:
        """
        mkdir -p {params.outdir}
        awk -v OFS="\\t" '{{
            region=$1":"$2"-"$3;
            outfile="{params.outdir}/"region".bed"
            print $1, $2, $3 > outfile
            print outfile > "{output.fofn}"
        }}' {input.regions}
        """

rule query_regions:
    input:
        paf=rules.ava_asm.output.paf,
        asm=rules.merge_asm.output,
        bed=join(rules.split_regions.params.outdir, "{region}.bed")
    output:
        fa_dir=directory(join(OUTPUT_DIR, "regions", "{region}")),
    log:
        join(LOG_DIR, "query_regions_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "query_regions_{region}.tsv")
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ impg query \
        -p {input.paf} \
        -b {input.bed} \
        -o fasta \
        --sequence-files {input.asm} | 
        seqkit split -i - --by-id-prefix "" -O {output.fa_dir} ;}} 2> {log}
        """


rule run_minigraph:
    input:
        fa_dir=rules.query_regions.output,
    output:
        rgfa=join(OUTPUT_DIR, "graphs", "{region}.rgfa"),
        gfa=join(OUTPUT_DIR, "graphs", "{region}.gfa"),
    params:
        min_mapq=1, 
        min_variant_length=1, 
        min_alignment_length=10,
        min_alignment_length_depth=10,
        region_seqkit=lambda wc: wc.region.replace(":", "__")
    log:
        join(LOG_DIR, "generate_variation_graph_{region}.log"),
    benchmark:
        join(BENCHMARK_DIR, "generate_variation_graph_{region}.tsv")
    threads: THREADS_MG
    resources:
        mem=MEM_MG,
    conda:
        "envs/tools.yaml"
    # TODO: Make sure reference always the region.
    shell:
        """
        ref_fasta=$(find {input.fa_dir} -name "*.fasta" -and -name "{params.region_seqkit}.fasta")
        qry_fasta=$(find {input.fa_dir} -name "*.fasta" -and -not -name "{params.region_seqkit}.fasta")
        if [ -z "${{qry_fasta}}" ] || [ -z "${{ref_fasta}}" ]; then
            touch {output}
            exit 0
        fi
        minigraph \
        -cx ggs \
        -t{threads} \
        ${{ref_fasta}} \
        ${{qry_fasta[@]}} \
        -q {params.min_mapq} \
        -L {params.min_variant_length} \
        -l {params.min_alignment_length} \
        -d {params.min_alignment_length_depth} > {output.rgfa} 2> {log}
        # Convert to GFAv1.1
        vg convert -g -f -W {output.rgfa} > {output.gfa} 2>> {log}
        """


rule convert_gfa_to_og:
    input:
        gfa=rules.run_minigraph.output.gfa
    output:
        og=join(OUTPUT_DIR, "graphs", "{region}.og"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        if [ -s {input.gfa} ]; then
            odgi build -g {input.gfa} -o {output.og}
        else
            touch {output}
        fi
        """


rule merge_format_annotations:
    input:
        ANNOTATIONS
    output:
        bed=join(OUTPUT_DIR, "bed", "merged_annotations.bed"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        zcat -f {input} | cut -f 1-4 | sort -k1,1 -k2,2n > {output.bed}
        """

rule inject_annot_and_cvt_to_gfa:
    input:
        og=rules.convert_gfa_to_og.output.og,
        annotations=rules.merge_format_annotations.output,
    output:
        bed_inj=join(OUTPUT_DIR, "bed", "{region}_injected.bed"),
        og_inj=join(OUTPUT_DIR, "graphs", "{region}_injected.og"),
        gfa_inj=join(OUTPUT_DIR, "graphs", "{region}_injected.gfa"),
    conda:
        "envs/tools.yaml"
    shell:
        """
        if [ ! -s {input.og} ]; then
            touch {output}
            exit 0
        fi
        # Convert region wildcard to BED file in relative coordinate system.
        # * First convert to path system, strip the coordinates, intersect with bed, and then add them back and revert back to path system.
        # * Add increment so all path names are unique.
        # * odgi procbed's path name parsing didn't work for me.
        bedtools intersect \
            -a {input.annotations} \
            -b <(odgi paths -Ll -i {input.og} | awk -v OFS="\\t" '{{ match($1, "^(.+):(.+)-", arr); print arr[1], $2+arr[2], $3+arr[2], arr[2]}}') \
            -wa -wb | \
        awk -v OFS="\\t" '{{
            path_st=$(NF-2);
            path_end=$(NF-1);
            path_len=path_end-path_st; 
            chrom_st=$(NF);
            new_st=$2-chrom_st;
            new_st=(new_st > 0) ? new_st + 1 : 0;
            new_end=$3-chrom_st;
            new_end=(new_end > path_len) ? path_len : new_end;
            path_name=$1":"path_st-1"-"path_end
            print path_name, new_st, new_end + 1, $4"_"NR
        }}' > {output.bed_inj}
        odgi inject -i {input.og} -b {output.bed_inj} -o {output.og_inj}
        odgi view -i {output.og_inj} --to-gfa > {output.gfa_inj}
        """

# TODO: Call variants and overlap with regions.

def variant_graphs(wc):
    fofn = checkpoints.split_regions.get(**wc).output.fofn
    regions = []
    with open(fofn, "rt") as fh:
        for bed in fh:
            bed = bed.strip()
            with open(bed, "rt") as bfh:
                for line in bfh:
                    chrom, st, end = line.strip().split("\t")
                    regions.append(f"{chrom}:{st}-{end}")

    outputs = []
    outputs.extend(expand(rules.run_minigraph.output, region=regions))
    outputs.extend(expand(rules.inject_annot_and_cvt_to_gfa.output, region=regions))
    return outputs
     
rule generate_variation_graphs:
    input:
        rules.split_regions.output,
        variant_graphs,
    output:
        touch(join(OUTPUT_DIR, "checkpoints", "all_graphs.done"))


rule all:
    input:
        rules.generate_variation_graphs.output,
    default_target: True
